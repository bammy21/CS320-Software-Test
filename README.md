# CS320 – Software Test Portfolio

**Author:** Konigbagbe G. Fisayo

## Overview
This repository contains portfolio artifacts from CS-320: Software Test, Automation, and Quality Assurance.  
It demonstrates unit testing, automation, and software quality assurance techniques using **Java** and **JUnit**.

---

## Project One – Contact Service

### Files Included
- Contact.java  
- ContactService.java  
- ContactTest.java  
- ContactServiceTest.java  

### Description
This project demonstrates the implementation of a contact management service with enforced constraints and automated unit testing. JUnit tests were used to validate correct behavior, handle invalid inputs, and ensure reliability.

---

## Project Two – Summary and Reflections

### Files Included
- Summary and Reflections Report

### Description
This document reflects on my testing approach, challenges, and lessons learned while developing and testing software using automated testing strategies.

---

## Reflection

### How can I ensure that my code, program, or software is functional and secure?
I ensure my software is functional and secure by implementing automated unit tests, validating inputs, and enforcing constraints within the code. In Project One, JUnit tests verified correct behavior, edge cases, and exception handling. These practices help prevent invalid states and ensure continued reliability after code changes.

### How do I interpret user needs and incorporate them into a program?
I interpret user needs by analyzing requirements and translating them into functional behaviors and constraints within the software. I then validate those behaviors using unit tests that simulate both valid and invalid user input, ensuring the application behaves as expected.

### How do I approach designing software?
I approach software design by breaking requirements into modular components, separating responsibilities between data models, services, and tests. Writing tests alongside implementation allows me to verify design decisions early and improve maintainability and code quality.
