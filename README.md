/*
 * CS320 – Software Test, Automation, and Quality Assurance
 * Author: Konigbagbe G. Fisayo
 *
 * This repository contains portfolio artifacts from CS-320
 * demonstrating unit testing, automation, and software quality
 * assurance techniques using Java and JUnit.
 */

========================
= Portfolio Overview  =
========================

/*
 * Project One – Contact Service
 *
 * Files Included:
 *  - Contact.java
 *  - ContactService.java
 *  - ContactTest.java
 *  - ContactServiceTest.java
 *
 * This project demonstrates:
 *  - Translating software requirements into code
 *  - Enforcing data validation and constraints
 *  - Writing automated unit tests using JUnit
 *  - Using testing to detect defects early
 */

/*
 * Project Two – Summary and Reflections Report
 *
 * This document reflects on:
 *  - Unit testing strategies used in the course
 *  - Challenges encountered while writing tests
 *  - Lessons learned about automation and quality assurance
 */

================
= Reflection  =
================

/*
 * Q1: How can I ensure that my code, program, or software is functional and secure?
 *
 * I ensure functionality by writing unit tests that verify each method
 * behaves as expected under normal and edge-case conditions. Automated
 * testing helps catch defects early and ensures that changes do not break
 * existing functionality. While this course focuses on testing rather than
 * security, validating inputs and enforcing constraints also helps prevent
 * unexpected behavior.
 */

/*
 * Q2: How do I interpret user needs and incorporate them into a program?
 *
 * I interpret user needs by carefully reviewing requirements and converting
 * them into specific rules within the code. For example, in the Contact
 * Service, user requirements such as field length limits and required values
 * were enforced through validation logic. Unit tests were then written to
 * confirm that these rules were consistently applied.
 */

/*
 * Q3: How do I approach designing software?
 *
 * I approach software design by separating responsibilities into clear,
 * maintainable components. Data models, service logic, and test classes
 * are kept independent. Writing tests alongside the code allows me to
 * validate design decisions early and adjust the implementation before
 * defects become more complex or costly.
 */

========================
= End of README File  =
========================
